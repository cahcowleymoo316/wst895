##################################################################################
# Function to create colours for map variable 
#     Arguments:                                                                      
#     var         - variable that will be assigned colours 
#     num_colours - number of colours to generate, 
#     brewerpal   - palette from RColorBrewer. To see all available palettes,
#                   run display.brewer.all() NB! Make sure RColorBrewer is loaded.
# Returns: 
#     class       - classes of variable
#     colour      - list of colours
#     uniquecolour- list of unique colours in order
fn_mapcolours <- function(var
                          , num_colours = 9
                          , brewerpal = "Greens"
                          , dig.lab = 0){
        require(RColorBrewer)
        my_colours <- brewer.pal(num_colours, brewerpal) 
        my_colours1 <- colorRampPalette(my_colours)(num_colours)
        
        # Chloropleth from https://www.r-graph-gallery.com/choropleth-map-in-r.html
        # Attribute the appropriate color to each country
        class <- cut(var, num_colours, dig.lab = dig.lab)
        my_colours2 <- my_colours1[as.numeric(class)]
        my_colours2
        final <- list(class = class
                      , colour = my_colours2
                      , uniquecolour = my_colours1)
        return(final)
}
##################################################################################

##################################################################################
# Function to plot SpatialPolygonsDataFrame
#     Arguments:                                                                      
#     spdf        - SpatialPolygonsDataFrame 
#     colours     - colour list generated by fn_mapcolours
#     bordercol   - colour of polygon borders (default set to "transparent")
#     main        - plot title (use \n for new line)
#     legend.pos  - where to place legend (default set to NULL)
#     legend.inset- how far to inset legend from border (default set to 0.005)
#     legend.title- legend header
# Returns: 
#     your plot!
fn_spdfplot <- function(spdf
                        , colours
                        , bordercol = "transparent"
                        , main
                        , legend.pos = NULL
                        , legend.inset = 0.005
                        , legend.title){
        require(raster)
        if(class(spdf) == "SpatialPolygonsDataFrame"){
                raster::plot(x = spdf, col = colours$colour, main = main, border = bordercol)
        }
        if(class(spdf) == "SpatialPointsDataFrame"){
                raster::plot(x = spdf, col = colours$colour, main = main, pch = 19)
        }
        if(!is.null(legend.pos)){
                legend(legend.pos
                       , inset = legend.inset
                       , legend = levels(colours$class)
                       , fill = colours$uniquecolour
                       , bty = "n"
                       , title = legend.title)
        }
}
##################################################################################

##################################################################################
# Function to define neighbourhoods and assign weights to neighbours
#     Arguments:                                                                      
#     spdf        - SpatialPolygonsDataFrame 
#     queen       - specifies whether queen/rook contiguity condition should be used (default set to TRUE)
#     style       - weigthing scheme to use (default = "W" - simple average)
#     zero.policy - defines how missings are treated, if TRUE then missings are replaced with 0 (default set to FALSE)
# Returns: 
#     nb          - list of neighbourhoods for each spatial entity
#     lw          - list of weights for each of the neighbours of each spatial entity
fn_neighbours <- function(spdf, queen = T, k = 3, style= "W", zero.policy = T){
        require(spdep)
        if(class(spdf)[1] == "SpatialPolygonsDataFrame"){
                nb <- spdep::poly2nb(spdf, queen=queen)
                lw <- spdep::nb2listw(nb, style=style, zero.policy=zero.policy)
        }
        if(class(spdf)[1] == "SpatialPointsDataFrame"){
                nb <- spdep::knn2nb(spdep::knearneigh(spdf, k = k))
                lw <- spdep::nb2listw(nb,style = style,)
        }
        final <- list(nb = nb
                      , lw = lw)
        return(final)
}

##################################################################################
# Function to create Moran's scatterplot
fn_moranscatter <- function(spdf
                            , lw
                            , var
                            , title
                            , col ="red"
                            , zero.policy = F){
        # Create spatial lags of variable
        spat.lag <- spdep::lag.listw(lw, spdf@data[,var], zero.policy = zero.policy)
        # Fit linear model
        M1 <- lm(spat.lag ~ spdf@data[,var])
        # Save plot as a function in order to save base plot. 
        plotter <- function(spat.lag, spdf, var, title, col){
                # Plot spatial lags against actuals
                plot(spat.lag ~ spdf@data[,var], pch=16, asp=1, col = col
                     , xlab = "Observed value"
                     , ylab = "Spatial lag")
                title(main = title)
                # OPTIONAL: Add Moran's I value
                #abline(M1, col=col, lwd = 2)
                #title(main = title
                #      , sub = paste("Moran's I =", round(M1$coefficients[2],3)))
        }
        moranscatter <- function(){plotter(spat.lag, spdf, var, title, col)}
        
        final <- list(I = M1$coefficients[2]
                      , moranscatter = moranscatter)
        return(final)
}
##################################################################################

##################################################################################
# Function to create Local Moran's I values
fn_localmoran <- function(spdf
                          , lw
                          , var
                          , zero.policy = F){
        local_moran <- spdep::localmoran(spdf@data[,var]
                                         , listw = neighbour$lw
                                         , zero.policy = F)
        spdf.new <- data.frame(spdf, local_moran)
        return(spdf.new)
}

# Function to create Local Moran's I quadrant
fn_quadrant <- function(spdf,lw, var, sig = 0.05){
        adf <- as.data.frame(spdf[, var])
        sdf <- as.data.frame(spdf[, "Pr.z...0."])
        quadrant <- vector(mode="numeric",length=nrow(spdf))
        # centers the variable of interest around its mean
        m.var <- adf[,1] - mean(adf[,1], na.rm = T)    
        var.lag <- lag.listw(lw, adf[,1])
        m.var.lag <- var.lag - mean(var.lag, na.rm = T)
        # significant Income threshold
        signif <- sig
        # builds a data quadrant
        quadrant[m.var >0 & m.var.lag>0] <- 4  
        quadrant[m.var <0 & m.var.lag<0] <- 1      
        quadrant[m.var <0 & m.var.lag>0] <- 2
        quadrant[m.var >0 & m.var.lag<0] <- 3
        quadrant[sdf[,1]>signif] <- 0
        
        final <- list(standardised = m.var
                      , stand.lag = m.var.lag
                      , quadrant = quadrant)
        return(final)
}


# Function to plot LISA quadrants
fn_plotLISAquad <- function(spdf, var, varname.print = NULL, quadrant, legend.pos, graph.legend = 1, margin){
        if(is.null(varname.print)){varname.print <- var}
        m.var.lag <- quadrant$stand.lag
        m.var <- quadrant$standardised
        par(mfrow=c(1,2), mar = rep(margin,4), bg = "Grey80")
        brks <- c(0,1,2,3,4)
        colors <- c("grey50","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
        
        plot(m.var.lag~m.var, col = colors[findInterval(quadrant$quadrant,brks,all.inside=FALSE)]
             , xlab = "Standardised Observed"
             , ylab = "Standardised Spatial-Lag"
             , main = "LISA clusters"
             , pch = 16)
        abline(v = 0, h = 0, lty = 3)
        if(!is.null(legend.pos)){
                legend(legend.pos
                       , title = "Cluster"
                       , legend = c("I","L-L","L-H","H-L","H-H")
                       , fill=colors
                       , bty="n")
        }
        fn_LISApercentages(quadrant = quadrant, varname = varname, varname.print = varname.print)$plot()
        
        
}

fn_LISAclustermap <- function(spdf, title, colors, quadrant){
        brks <- c(0,1,2,3,4)
        colors <- c("grey50","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
        if(class(spdf) == "SpatialPolygonsDataFrame"){
                plot(spdf, col = colors[findInterval(quadrant$quadrant,brks,all.inside=FALSE)]
                     , main = title
                     , border = "transparent")
        }
        if(class(spdf) == "SpatialPointsDataFrame"){
                plot(spdf, col = colors[findInterval(quadrant$quadrant,brks,all.inside=FALSE)]
                     , main = title
                     , pch = 19
                     , border = "transparent")
        }
}

# Function to calculate bivariate Moran's I statistics
fn_bivariatemoran <- function(x
                              , y 
                              , nb
                              , nsims = 1000
                              , sig = 0.05){
        require(spatialreg)
        require(Matrix)
        lw1 <- nb2listw(nb, style = "B", zero.policy = T)
        W  <- as(lw1, "symmetricMatrix",strict = F)
        W  <- as.matrix(W/rowSums(W))
        W[which(is.na(W))] <- 0
        
        xp <- (x - mean(x, na.rm=T))/sd(x, na.rm=T)
        yp <- (y - mean(y, na.rm=T))/sd(y, na.rm=T)
        W[which(is.na(W))] <- 0
        n <- nrow(W)
        
        global <- (xp%*%W%*%yp)/(n - 1)
        local  <- (xp*W%*%yp)
        
        
        # Permutations for the Bivariate Moran's I
        n   = nrow(W)
        IDs = 1:n
        
        xp <- (x - mean(x, na.rm=T))/sd(x, na.rm=T)
        W[which(is.na(W))] <- 0
        
        global_sims = NULL
        local_sims  = matrix(NA, nrow = n, ncol=nsims)
        
        ID_sample = sample(IDs, size = n*nsims, replace = T)
        
        y_s = y[ID_sample]
        y_s = matrix(y_s, nrow = n, ncol = nsims)
        y_s <- (y_s - apply(y_s, 1, mean))/apply(y_s, 1, sd)
        
        global_sims  <- as.numeric( (xp%*%W%*%y_s)/(n - 1) )
        local_sims  <- (xp*W%*%y_s)
        
        # Identifying the significant values  for the local simulations
        probs <- c(sig/2, 1-sig/2)
        intervals <- t( apply(local_sims, 1, function(x) quantile(x, probs=probs)))
        sigs        <- ( local < intervals[,1] )  | ( local > intervals[,2] )
        
        final <- list(W = W
                      , global = global
                      , global_sims = global_sims
                      , local  = as.numeric(local)
                      , local_sims  = local_sims
                      , local_sig = sigs)
        return(final)
}




# Function to create bivariate Local Moran's I quadrants
fn_bivariatequadrant <- function(x, y, sig, W){
        xp <- (x-mean(x, na.rm = T))/sd(x, na.rm = T)
        yp <- (y-mean(y, na.rm = T))/sd(y, na.rm = T)
        require(stringr)
        patterns <- as.character( interaction(xp > 0, W%*%yp > 0) ) 
        patterns <- patterns %>% 
                stringr::str_replace_all("TRUE","High") %>% 
                str_replace_all("FALSE","Low")
        patterns[sig==0] <- "Not significant"
        
        # builds a data quadrant
        quadrant <- vector(mode="numeric",length=length(x))
        quadrant[xp >0 & yp>0] <- 4  
        quadrant[xp <0 & yp<0] <- 1      
        quadrant[xp <0 & yp>0] <- 2
        quadrant[xp >0 & yp<0] <- 3
        quadrant[sig == F] <- 0 
        quadrant
        final <- list(xp = xp
                      , yp = yp
                      , quadrant = quadrant)
        return(final)
        
}

# Function to plot bivariate LISA quadrants and spatial clusters

# Function to plot LISA quadrants
fn_plotbivariateLISAquad <- function(quadrant){
        require(raster)
        par(mfrow=c(1,2), mar = rep(margin,4), bg = "Grey80")
        brks <- c(0,1,2,3,4)
        colors <- c("grey50","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
        raster::plot(quadrant$x~quadrant$y, col = colors[findInterval(quadrant$quadrant,brks,all.inside=FALSE)]
                     , xlab = "Standardised Observed"
                     , ylab = "Standardised Spatial-Lag"
                     , main = "Bivariate LISA clusters"
                     , pch = 16)
        abline(v = 0, h = 0, lty = 3)
        if(!is.null(legend.pos)){
                legend(legend.pos
                       , title = "Cluster"
                       , legend = c("I","L-L","L-H","H-L","H-H")
                       , fill=colors
                       , bty="n")
        }
        
        fn_LISApercentages(quadrant = quadrant, varname = varname, varname.print = varname.print)$plot()
}

# Function to plot percentage of LISA clusters

fn_LISApercentages <- function(quadrant, varname, varname.print = NULL){
        if(is.null(varname.print)){varname.print <- varname}
        colors <- c("grey50","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
        
        
        quadrant.summary <- data.frame(quadrant = c(0,1,2,3,4)
                                       , quadrant_name = c("insignificant","low-low","low-high","high-low","high-high")
                                       , quadrant_name_short = c("I","L-L","L-H","H-L","H-H")) %>% 
                dplyr::left_join(data.frame(quadrant=quadrant$quadrant) %>% 
                                         dplyr::group_by(quadrant) %>% 
                                         dplyr::summarise(n = n()), by = "quadrant") %>% 
                dplyr::mutate(n = ifelse(is.na(n), 0, n)) %>%
                dplyr::mutate(perc_all = paste0(round(n/sum(n)*100,2),"%")) %>% 
                dplyr::mutate(colors = colors) %>% 
                data.frame
        
        quadrant.summary2 <- quadrant.summary %>%
                dplyr::mutate(cluster_yn = ifelse(quadrant == 0, 0, 1)) %>% 
                dplyr::group_by(cluster_yn) %>% 
                dplyr::summarise(sum_cluster = sum(n)) %>% 
                dplyr::mutate(perc_cluster = paste0(round(sum_cluster/sum(sum_cluster), 4)*100, "%")) %>% 
                dplyr::filter(cluster_yn == 1) %>% 
                data.frame
        bp <- function(quadrant.summary, quadrant.summary2, varname, varname.print = varname.print, qaudrant_name_short){
                #par(mfrow=c(1,1), mar = c(6,6,6,6), bg = "Grey80")
                
                p <- barplot(quadrant.summary$n
                             , names.arg = quadrant.summary$quadrant_name_short
                             , col = colors
                             , xlab = "LISA cluster"
                             , main = paste("Spatial entities in LISA clusters \n", varname.print)
                             , sub = paste("% of LISA Clusters =", quadrant.summary2$perc_cluster))
                text(x = p
                     , y = quadrant.summary$n
                     , label = quadrant.summary$n
                     , pos = 1
                     , col = "Grey80")
                legend("topright"
                       , title = "Cluster"
                       , legend = paste(quadrant.summary$quadrant_name_short, "=", quadrant.summary$perc_all)
                       , fill=colors)  
        }
        plot1 <- function(){bp(quadrant.summary, quadrant.summary2, varname, varname.print)}
        final <- list(plot = plot1)
        return(final)
}

# Function to calculate dispersion
fn_dispersion <- function(spdf, vars){
        require(dplyr)
        dispersion <- apply(data.frame(spdf) %>% dplyr::select(vars), 2, function(x) var(x, na.rm = T)/mean(x, na.rm = T))
        df <- data.frame(vars, dispersion)
        rownames(df) <- 1:length(vars)
        return(df)
}
